# Distaff
Distaff is a zero-knowledge virtual machine written in Rust. For any program executed on Distaff VM, a STARK-based proof of execution is automatically generated. This proof can then be used by anyone to verify that a program was executed correctly without the need for re-executing the program or even knowing what the program was.

### Status
**DO NOT USE IN PRODUCTION.** Distaff is in a very early alpha. This means that current functionality is limited, and there are known and unknown bugs and security flaws.

## Usage
Distaff exposes `processor` module which can be used to execute programs and verify their execution. Both are explained below, but you can also take a look at a working example of a program which calculates n-th term of a Fibonacci sequence [here](https://github.com/GuildOfWeavers/distaff/blob/master/src/main.rs).

### Executing a program 
To execute a program on Distaff VM, you can use `processor::execute()` function. The function takes the following parameters:

* `program: &[u64]` - the program to be executed, which is just a sequence of [instructions](#Instruction-set).
* `inputs: &[u64]` - inputs for the program. These will be used to initialize the stack. Currently, at most 8 inputs can be provided.
* `num_outputs: usize` - number of elements on the stack to be returned as program output. Currently, at most 8 outputs can be returned.
* `options: &ProofOptions` - config parameters for proof generation. The default options target 96-bit security level.

If the program is executed successfully, the function returns a tuple with 3 elements:

* `outputs: Vec<u64>` - the outputs generated by the program. The number of elements in the vector will be equal to the `num_outputs` parameter.
* `program_hash: [u8; 32]` - an array of 32 bytes representing a hash of the program (see [here](#Program-hash) for more info).
* `proof: StarkProof` - proof of program execution. `StarkProof` implements `serde`'s `Serialize` and `Deserialize` traits - so, it can be easily serialized and de-serialized.

#### Program execution example
Here is a simple example of executing a program which pushes two numbers onto the stack and computes their sum:
```Rust
use distaff::{ ProofOptions, processor, processor::opcodes };

// this is our program
let program = [
    opcodes::PUSH, 1,
    opcodes::PUSH, 2,
    opcodes::ADD
];

// let's execute it
let (outputs, program_hash, proof) = processor::execute(
        &program,
        &[],        // we won't initialize the stack with any inputs
        1,          // a single item form the stack will be returned
        &ProofOptions::default()); // we'll be using default options

// the output should be 3
assert_eq!(vec![3], outputs);
```

### Verifying program execution
To verify program execution, you can use `processor::verify()` function. The function takes the following parameters:

* `program_hash: &[u8; 32]` - an array of 32 bytes representing a hash of the program to be verified.
* `inputs: &[u64]` - a list of inputs against which the program was executed.
* `outputs: &[u64]` - a list of outputs generated by the program.
* `proof: &StarkProof` - the proof generated during program execution.

The function returns `Result<bool, String>` which will be `Ok<true>` if verification passes, or `Err<message>` if verification fails, with `message` describing the reason for the failure.

Verifying execution proof of a program basically means the following:

> If a program with the provided hash is executed against the provided inputs, it will produce the provided outputs.

Notice how the verifier needs to know only the hash of the program - not what the actual program was.

#### Verifying execution example
Here is a simple example of verifying execution of the program from the previous example:
```Rust
use distaff::{ processor };

let program_hash =  /* value from previous example */;
let proof =         /* value from previous example */;

// let's verify program execution
match processor::verify(&program_hash, &[], &[3], &proof) {
    Ok(_) => println!("Execution verified!"),
    Err(msg) => println!("Execution verification failed: {}", msg)
}
```

## Design

Distaff VM is a simple [stack machine](https://en.wikipedia.org/wiki/Stack_machine). This means all values live on the stack and all operations work with values near the top of the stack. 

### The stack
Currently, Distaff VM stack can be up to 32 items deep (this will be increased in the future). However, the more stack space a program uses, the longer it will take to execute, and the larger the execution proof will be. So, it pays to use stack space judiciously.

Values on the stack must be elements of a [prime field](https://en.wikipedia.org/wiki/Finite_field) with modulus `18446743880436023297` (which can also be written as 2<sup>64</sup> - 45 * 2<sup>32</sup> + 1). This means that all valid values are in the range between `0` and `18446743880436023296` - this covers almost all 64-bit integers.   

All arithmetic operations (addition, subtraction, multiplication) also happen in the same prime field. This means that overflow happens after a value exceeds field modulus. So, for example: `18446743880436023296 + 1 = 0`.

### Inputs / outputs
Currently, there are 2 ways to get values onto the stack:

1. You can initialize the stack with a set of inputs as described [here](#Executing-a-program). These inputs are the public inputs into the program. This means, that they must be shared with a verifier for them to verify program execution.
2. You can use `PUSH` operations to push values onto the stack as shown [here](#Program-execution-example). These values become a part of the program itself, and, therefore, cannot be changed between program executions. You can think of them as constants.

A way to specify secret inputs which can change between program executions is not yet available, but will be provided in the future.

Values remaining on the stack after a program is executed can be returned as program outputs. You can specify exactly how many values (from the top of the stack) should be returned. Currently, the number of outputs is limited to 8. A way to return a large number of values (hundreds or thousands) is not yet available, but will be provided in the future.

### Program hash

As described [here](#Executing-a-program), one of the values produced by Distaff VM after executing a program is program hash. This hash is a reduction of all program instructions into a single 32-byte value. The hash is generated as follows:

1. First, the program is padded with `NOOP` operations. The padding ensures that:
   1. The program consists of at least 16 operations.
   2. The number of operations is a power of 2 (16, 32, 64 etc.).
2. Then, a modified version of [Rescue](https://eprint.iacr.org/2019/426) hash function is used to sequentially hash all instructions together (see [code](https://github.com/GuildOfWeavers/distaff/blob/master/src/stark/utils/hash_acc.rs)). Security implications of this modification have not been analyzed. It is likely that this modification greatly reduces security of Rescue, and the hashing scheme will need to be changed in the future.

### Instruction set
Eventually, Distaff will have up to 40 (or more) instructions which will let you write sophisticated programs. For now, only the following 10 instructions have been implemented:

| Instruction | Opcode   | Description                            |
| ----------- | :------: | -------------------------------------- |
| NOOP        | 00000000 | Does not change the state of the stack. |
| PULL1       | 00001100 | Moves the second from the top stack item (item with index `1`) to the top of the stack. |
| PULL2       | 00001101 | Moves the third from the top stack item (item with index `2`) to the top of the stack. |
| PUSH        | 00010000 | Pushes the value of the next opcode onto the stack. The value can be any field element. |
| DUP0        | 00010001 | Pushes a copy of the top stack item onto the stack (duplicates the top stack item). |
| DUP1        | 00010010 | Pushes a copy of the second from the top stack item onto the stack. |
| DROP        | 00011000 | Removes the top item from the stack. |
| ADD         | 00011001 | Pops top two items from the stack, adds them, and pushes the result back onto the stack. |
| SUB         | 00011010 | Pops top two items from the stack, subtracts the top item from the second to the top item, and pushes the result back onto the stack. |
| MUL         | 00011011 | Pops top two items from the stack, multiplies them, and pushes the result back onto the stack. |

If you'd like to check out some of the potential future instructions, look [here](https://github.com/GuildOfWeavers/distaff/blob/master/src/processor/opcodes.rs).

#### Turing-completeness
Distaff VM is unlikely to be [Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness) in the foreseeable future. However, conditional execution (`if..else` statements), and maybe even bounded loops, will be supported.

#### Memory
Currently, Distaff VM has no random access memory - all values live on the stack. However, in the future, a memory module may be added, if it doesn't introduce too much computational overhead.

## Fibonacci calculator
Let's write a simple program for Distaff VM. This program will compute the 5-th [Fibonacci number](https://en.wikipedia.org/wiki/Fibonacci_number):

```
PUSH 0      // stack state: 0
PUSH 1      // stack state: 1 0
DUP0        // stack state: 1 1 0
PULL2       // stack state: 0 1 1
ADD         // stack state: 1 1
DUP0        // stack state: 1 1 1
PULL2       // stack state: 1 1 1
ADD         // stack state: 2 1
DUP0        // stack state: 2 2 1
PULL2       // stack state: 1 2 2
ADD         // stack state: 3 2
```
Notice that except for the first 2 operations which initialize the stack, the sequence of `DUP0 PULL2 ADD` operations repeats over and over. In fact, we can repeat these operations an arbitrary number of times to compute an arbitrary Fibonacci number. In Rust, it would like like this (this is actually a simplified version of the example in [main.rs](https://github.com/GuildOfWeavers/distaff/blob/master/src/main.rs)):
```Rust
use distaff::{ ProofOptions, processor, processor::opcodes };

// set the number of terms to compute
let n = 50;

// build the program
let mut program = Vec::new();
for _ in 0..(n - 1) {
    program.push(opcodes::DUP0);
    program.push(opcodes::PULL2);
    program.push(opcodes::ADD);
}

// execute the program
let (outputs, program_hash, proof) = processor::execute(
        &program,
        &[1, 0],    // initialize the stack with these inputs
        1,          // top stack item is the output
        &ProofOptions::default());

// the output should be the 50th Fibonacci number
assert_eq!(vec![12586269025], outputs);
```
Above, we used public inputs to initialize the stack rather than using `PUSH` operations. This makes the program a bit simpler, and also allows us to run the program from arbitrary starting points without changing program hash.

This program is rather efficient: the stack never gets more than 3 items deep.

## Performance
Here are some very informal benchmarks of running the Fibonacci calculator on Intel Core i5-7300U @ 2.60GHz (single thread) for a given number of operations (remember, it takes 3 operations to compute a single Fibonacci term):

| Operation Count | Execution time | Execution RAM  | Verification time | Proof size |
| --------------- | :------------: | :------------: | :---------------: | :--------: |
| 2<sup>8</sup>   | 40 ms          | negligible     | 2 ms              | 66 KB      |
| 2<sup>10</sup>  | 120 ms         | negligible     | 2 ms              | 87 KB      |
| 2<sup>12</sup>  | 450 ms         | negligible     | 2 ms              | 114 KB     |
| 2<sup>14</sup>  | 2 sec          | 130 MB         | 3 ms              | 140 KB     |
| 2<sup>16</sup>  | 8.6 sec        | 640 MB         | 3 ms              | 174 KB     |
| 2<sup>18</sup>  | 38 sec         | 2.6 GB         | 3 ms              | 214 KB     |
| 2<sup>20</sup>  | 6.3 min        | > 5.6 GB       | 4 ms              | 250 KB     |

A few notes about the results:
1. Execution time is dominated by the proof generation time. In fact, the time needed to run the program is only about 0.05% of the time needed to generate the proof.
2. For 2<sup>20</sup> case, RAM on my machine maxed out at 5.6 GB, but for efficient execution ~12 GB would be needed. This probably explains why proving time is so poor in this case as compared to other cases. If there was sufficient RAM available, execution time would have likely been just around 3 mins.
3. The benchmarks use default proof options which target 96-bit security level. The security level can be increased by either increasing execution time or proof size. In general, there is a trade-off between proof time and proof size (i.e. you can reduce proof size by increasing execution time, up to a point).

## References
Proofs of execution generated by Distaff VM are based on STARKs. A STARK is a novel proof-of-computation scheme that allows you to create an efficiently verifiable proof that a computation was executed correctly. The scheme was developed by Eli-Ben Sasson and team at Technion - Israel Institute of Technology. STARKs do not require an initial trusted setup, and rely on very few cryptographic assumptions.

Here are some resources to learn more about STARKs:

* STARKs whitepaper: [Scalable, transparent, and post-quantum secure computational integrity](https://eprint.iacr.org/2018/046)

Vitalik Buterin's blog series on zk-STARKs:
* [STARKs, part 1: Proofs with Polynomials](https://vitalik.ca/general/2017/11/09/starks_part_1.html)
* [STARKs, part 2: Thank Goodness it's FRI-day](https://vitalik.ca/general/2017/11/22/starks_part_2.html)
* [STARKs, part 3: Into the Weeds](https://vitalik.ca/general/2018/07/21/starks_part_3.html)

StarkWare's STARK Math blog series:
* [STARK Math: The Journey Begins](https://medium.com/starkware/stark-math-the-journey-begins-51bd2b063c71)
* [Arithmetization I](https://medium.com/starkware/arithmetization-i-15c046390862)
* [Arithmetization II](https://medium.com/starkware/arithmetization-ii-403c3b3f4355)
* [Low Degree Testing](https://medium.com/starkware/low-degree-testing-f7614f5172db)
* [A Framework for Efficient STARKs](https://medium.com/starkware/a-framework-for-efficient-starks-19608ba06fbe)

# License
[MIT](/LICENSE) Â© 2020 Guild of Weavers
# Distaff
Distaff is a zero-knowledge virtual machine written in Rust. For any program executed on Distaff VM, a STARK-based proof of execution is automatically generated. This proof can then be used by anyone to verify that a program was executed correctly without the need for re-executing the program or even knowing what the program was.

### Status
**DO NOT USE IN PRODUCTION.** Distaff is in a very early alpha. This means that current functionality is limited, and there are known and unknown bugs and security flaws.

## Usage
Distaff exposes `processor` module which can be used to execute programs and verify their execution. Both are explained below, but you can also take a look at a working example of a program which calculates n-th term of a Fibonacci sequence [here](https://github.com/GuildOfWeavers/distaff/blob/master/src/examples/fibonacci.rs).

### Executing a program 
To execute a program on Distaff VM, you can use `processor::execute()` function. The function takes the following parameters:

* `program: &[u128]` - the program to be executed, which is just a sequence of [instructions](#Instruction-set).
* `inputs: &ProgramInputs` - inputs for the program. These include public inputs used to initialize the stack, as well as secret inputs consumed during program execution (see below).
* `num_outputs: usize` - number of items on the stack to be returned as program output. Currently, at most 8 outputs can be returned.
* `options: &ProofOptions` - config parameters for proof generation. The default options target 120-bit security level.

If the program is executed successfully, the function returns a tuple with 3 elements:

* `outputs: Vec<u128>` - the outputs generated by the program. The number of elements in the vector will be equal to the `num_outputs` parameter.
* `program_hash: [u8; 32]` - an array of 32 bytes representing a hash of the program (see [here](#Program-hash) for more info).
* `proof: StarkProof` - proof of program execution. `StarkProof` implements `serde`'s `Serialize` and `Deserialize` traits - so, it can be easily serialized and de-serialized.

#### Program inputs
To provide inputs for a program, you must create a [ProgramInputs](https://github.com/GuildOfWeavers/distaff/blob/master/src/stark/inputs.rs.rs) object which can contain the following:

* A list of public inputs which will be used to initialize the stack. Currently, at most 8 public inputs can be provided.
* Two lists of secret inputs. These lists can be thought of as tapes `A` and `B`. You can use `READ` operations to read values from these tapes and push them onto the stack (see [here](#Input-operations)).

Besides the `ProgramInputs::new()` function, you can also use `ProgramInputs::from_public()` and `ProgramInputs:none()` convenience functions to construct the inputs object.

#### Program execution example
Here is a simple example of executing a program which pushes two numbers onto the stack and computes their sum:
```Rust
use distaff::{ ProofOptions, ProgramInputs, processor, processor::opcodes::f128 as opcodes };

// this is our program
let program = [
    opcodes::BEGIN,
    opcodes::PUSH, 1,
    opcodes::PUSH, 2,
    opcodes::ADD
];

// let's execute it
let (outputs, program_hash, proof) = processor::execute(
        &program,
        &ProgramInputs::none(),    // we won't provide any inputs
        1,                         // we'll return a single item from the stack
        &ProofOptions::default()); // we'll be using default options

// the output should be 3
assert_eq!(vec![3], outputs);
```

### Verifying program execution
To verify program execution, you can use `processor::verify()` function. The function takes the following parameters:

* `program_hash: &[u8; 32]` - an array of 32 bytes representing a hash of the program to be verified.
* `public_inputs: &[u128]` - a list of public inputs against which the program was executed.
* `outputs: &[u128]` - a list of outputs generated by the program.
* `proof: &StarkProof` - the proof generated during program execution.

The function returns `Result<bool, String>` which will be `Ok<true>` if verification passes, or `Err<message>` if verification fails, with `message` describing the reason for the failure.

Verifying execution proof of a program basically means the following:

> If a program with the provided hash is executed against some secret inputs and the provided public inputs, it will produce the provided outputs.

Notice how the verifier needs to know only the hash of the program - not what the actual program was.

#### Verifying execution example
Here is a simple example of verifying execution of the program from the previous example:
```Rust
use distaff::{ processor };

let program_hash =  /* value from previous example */;
let proof =         /* value from previous example */;

// let's verify program execution
match processor::verify(&program_hash, &[], &[3], &proof) {
    Ok(_) => println!("Execution verified!"),
    Err(msg) => println!("Execution verification failed: {}", msg)
}
```

## Design

Distaff VM is a simple [stack machine](https://en.wikipedia.org/wiki/Stack_machine). This means all values live on the stack and all operations work with values near the top of the stack. 

### The stack
Currently, Distaff VM stack can be up to 32 items deep (this will be increased in the future). However, the more stack space a program uses, the longer it will take to execute, and the larger the execution proof will be. So, it pays to use stack space judiciously.

Values on the stack must be elements of a [prime field](https://en.wikipedia.org/wiki/Finite_field) with modulus `340282366920938463463374557953744961537` (which can also be written as 2<sup>128</sup> - 45 * 2<sup>40</sup> + 1). This means that all valid values are in the range between `0` and `340282366920938463463374557953744961536` - this covers almost all 128-bit integers.   

All arithmetic operations (addition, multiplication) also happen in the same prime field. This means that overflow happens after a value exceeds field modulus. So, for example: `340282366920938463463374557953744961536 + 1 = 0`.

Besides being field elements, values in Distaff VM are untyped. However, some operations expect binary values and will fail if you attempt to execute them using non-binary values. Binary values are values which are either `0` or `1`.

### Inputs / outputs
Currently, there are 3 ways to get values onto the stack:

1. You can use `PUSH` operations to push values onto the stack as shown [here](#Program-execution-example). These values become a part of the program itself, and, therefore, cannot be changed between program executions. You can think of them as constants.
2. You can initialize the stack with a set of public inputs as described [here](#Program-inputs). Because these inputs are public, they must be shared with a verifier for them to verify program execution.
3. You can provide unlimited number of secret inputs via input tapes `A` and `B`. Similar to public inputs, these tapes are defined as a part of [program inputs](#Program-inputs). To move secret inputs onto the stack, you'll need to use `READ` operations as described [here](#Input-operations).

Values remaining on the stack after a program is executed can be returned as program outputs. You can specify exactly how many values (from the top of the stack) should be returned. Currently, the number of outputs is limited to 8. A way to return a large number of values (hundreds or thousands) is not yet available, but will be provided in the future.

### Instruction set
Distaff VM already has a rich set of instructions which make it possible to write moderately complex programs. However, some key operations (e.g. value comparison) are still missing. The current instruction set is described below.

#### Flow control operations

| Instruction | Opcode   | Description                             |
| ----------- | :------: | --------------------------------------- |
| NOOP        | 00000000 | Does nothing. |
| BEGIN       | 11111111 | Marks the beginning of a program. Every program must start with the `BEGIN` operation. |

#### Input operations

| Instruction | Opcode   | Description                            |
| ----------- | :------: | -------------------------------------- |
| PUSH        | 00001000 | Pushes the value of the next opcode onto the stack. The value can be any field element. |
| READ        | 00001001 | Pushes the next value from the input tape `A` onto the stack. |
| READ2       | 00001010 | Pushes the next values from input tapes `A` and `B` onto the stack. Value from input tape `A` is pushed first, followed by the value from input tape `B`. |

#### Stack manipulation operations

| Instruction | Opcode   | Description                            |
| ----------- | :------: | -------------------------------------- |
| DUP         | 00001011 | Pushes a copy of the top stack item onto the stack (duplicates the top stack item). |
| DUP2        | 00001100 | Pushes copies of the top two stack items onto the stack. |
| DUP4        | 00001101 | Pushes copies of the top four stack items onto the stack. |
| PAD2        | 00001110 | Pushes two `0` values onto the stack. Equivalent to `PUSH 0 DUP`. |
| DROP        | 00010000 | Removes the top item from the stack. |
| DROP4       | 00010001 | Removes top four items from the stack. |
| SWAP        | 00011010 | Moves the second from the top stack item to the top of the stack (swaps top two stack items). |
| SWAP2       | 00011011 | Moves 3rd and 4th stack items to the top of the stack. For example, assuming `S0` is the top of the stack, `S0 S1 S2 S3` becomes `S2 S3 S0 S1`. |
| SWAP4       | 00011100 | Moves 5th through 8th stack items to the top of the stack. For example, assuming `S0` is the top of the stack, `S0 S1 S2 S3 S4 S5 S6 S7` becomes `S4 S5 S6 S7 S0 S1 S2 S3`. |
| ROLL4       | 00011101 | Moves 4th stack item to the top of the stack. For example, assuming `S0` is the top of the stack, `S0 S1 S2 S3` becomes `S3 S0 S1 S2`.  |
| ROLL8       | 00011110 | Moves 8th stack item to the top of the stack. For example, assuming `S0` is the top of the stack, `S0 S1 S2 S3 S4 S5 S6 S7` becomes `S7 S0 S1 S2 S3 S4 S5 S6`. |

#### Conditional operations

| Instruction | Opcode   | Description                            |
| ----------- | :------: | -------------------------------------- |
| CHOOSE      | 00010110 | Pops 3 values from the top of the stack, and pushes either the 1st or the 2nd value back onto the stack depending on whether the 3rd value is `1` or `0`. For example, assuming `S0` is the top of the stack, `S0 S1 1` becomes `S0`, while `S0 S1 0` becomes `S1`. This operation will fail if the 3rd stack item is not a binary value. |
| CHOOSE2     | 00010111 | Pops 6 values from the top of the stack, and pushes either the 1st or the 2nd pair of values back onto the stack depending on whether the 5th value is `1` or `0`. For example, assuming `S0` is the top of the stack, `S0 S1 S2 S3 1 S5` becomes `S0 S1`, while `S0 S1 S2 S3 0 S5` becomes `S2 S3` (notice that `S5` is discarded in both cases). This operation will fail if the 5th stack item is not a binary value. |

#### Arithmetic and boolean operations

| Instruction | Opcode   | Description                            |
| ----------- | :------: | -------------------------------------- |
| ADD         | 00011001 | Pops top two items from the stack, adds them, and pushes the result back onto the stack. |
| MUL         | 00011010 | Pops top two items from the stack, multiplies them, and pushes the result back onto the stack. |
| INV         | 00000011 | Pops the top item from the stack, computes its multiplicative inverse, and pushes the result back onto the stack. This can be used to emulate division with a sequence of two operations: `INV MUL`. If the value at the top of the stack is `0`, the operation will fail.
| NEG         | 00000100 | Pops the top item from the stack, computes its additive inverse, and pushes the result back onto the stack. This can be used to emulate subtraction with a sequence of two operations: `NEG ADD` |
| NOT         | 00000101 | Pops the top item from the stack, subtracts it from value `1` and pushes the result back onto the stack. In other words, `0` becomes `1`, and `1` becomes `0`. This is equivalent to `PUSH 1 SWAP NEG ADD` but also enforces that the top stack item is a binary value. |

#### Cryptographic operations

| Instruction | Opcode   | Description                            |
| ----------- | :------: | -------------------------------------- |
| HASHR       | 00011000 | Pops top 6 items from the stack, computes a single round of a modified [Rescue](https://eprint.iacr.org/2019/426) hash function over these values, and pushes the results back onto the stack. This operation can be used to hash up to two 256-bit values. However, to achieve 120 bits of security, the `HASHR` operation must be applied at least 10 times in a row (see [here](#Hashing-in-Distaff-VM)).  |

#### Potential future operations
Distaff VM is still missing a few important instructions. Specifically, comparing values is not currently supported. This makes programs with sophisticated conditional logic unsuitable for Distaff VM. To remedy this, new instructions will be added to the VM in the near future.

### Hashing in Distaff VM
To compute hashes in Distaff VM you can use `HASHR` operation. This operation works with the top 6 items of the stack, and depending on what you want to do, you should position the values on the stack in specific orders.

Generally, we want to hash values that are 256 bits long. And since all values in Distaff VM are about 128 bits, we'll need 2 elements to represent each 256-bit value. By convention, values to be hashed are placed in the inner-most positions on the stack, and the result of hashing is also located in the inner-most positions.

For example, suppose we wanted to compute `hash(x)`. First, we'd represent `x` by a pair of elements `(x0, x1)`, and then we'd position these elements on the stack like so:
```
[0, 0, 0, 0, x1, x0]
```
In other words, the first 4 items of the stack should be set to `0`'s, and the following 2 items should be set to the elements representing the value we want to hash.

If we wanted to compute a hash of two values `hash(x, y)`, represented by elements `(x0, x1)` and `(y0, y1)` respectively, we'd position them on the stack like so:
```
[0, 0, y1, y0, x1, x0]
```
In both cases, after the hashing is complete, the result will be located in the 5th and 6th positions of the stack (the result is also represented by two 128-bit elements).

#### Hashing programs

Hashing requires multiple invocations of `HASHR` operation, and there are a few things to be aware of:
1. To achieve adequate security (e.g. 120-bits), `HASHR` operation must be executed at least 10 times in a row. This is because each `HASHR` operation computes a single round of the hash function, and at least 10 rounds are required to achieve adequate security.
2. `HASHR` operation uses a schedule of constants which repeat every 16 steps. So, to make sure you get consistent results, the first `HASHR` operation in every sequence must happen on the step which is a multiple of 16 (e.g. 16, 32, 48 etc.). To ensure this alignment, you can always use `NOOP` operations to pad your programs.
3. The top two stack items are reserved for internal operations of the hash function. You need to make sure they are set to `0`'s before you start hashing values. This also means, that you can hash at most two 256-bit values at a time.

You can think of sequences of `HASHR` operations as of "mini-programs". Below is an example of a program which reads two 256-bit values from input tape `A` and computes their hash:
```
BEGIN NOOP  NOOP  NOOP  NOOP  NOOP  NOOP  NOOP
NOOP  NOOP  NOOP  READ  READ  READ  READ  PAD2
HASHR HASHR HASHR HASHR HASHR HASHR HASHR HASHR
HASHR HASHR DROP4
```
A quick explanation of what's happening here:
1. First, we pad the beginning of the program with `NOOP`'s so that the first `HASHR` operation happens on the 16th step.
2. Then, we read 4 values from the input tape `A`. These 4 values represent our two 256-bit values. We also push two `0`'s onto the stack by executing `PAD2` operation.
3. Then, we execute `HASHR` operation 10 times. Notice again that the first `HASHR` operation is executed on the 16th step.
4. The result of hashing is now in the 5th and 6th positions of the stack. So, we remove top 4 times from the stack (using `DROP4` operation) to move the result to the top of the stack.

You can also check an example of a more sophisticated program which uses `HASHR` operation to verify a Merkle authentication path [here](https://github.com/GuildOfWeavers/distaff/blob/master/src/examples/merkle.rs).

#### Hash function
As mentioned previously, Distaff VM uses a modified version of [Rescue](https://eprint.iacr.org/2019/426) hash function. This modification adds half-rounds to the beginning and to the end of the standard Rescue hash function to make the arithmetization of the function fully foldable. High-level pseudo-code for the modified version looks like so:
```
for 10 iterations do:
    add round constants;
    apply s-box;
    apply MDS;
    add round constants;
    apply inverse s-box;
    apply MDS;
```
This modification should not impact security properties of the function, but it is worth noting that it has not been studied to the same extent as the standard Rescue hash function.

Another thing to note: current implementation of the hash function uses S-Box of power 3, but this will likely be changes to S-Box of power 5 in the future.

### Program hash

As described [here](#Executing-a-program), one of the values produced by Distaff VM after executing a program is program hash. This hash is a reduction of all program instructions into a single 32-byte value. The hash is generated as follows:

1. First, the program is padded with `NOOP` operations. The padding ensures that:
   1. The program consists of at least 16 operations.
   2. The number of operations is a power of 2 (16, 32, 64 etc.).
2. Then, a hash function is used to sequentially hash all instructions together. This hash function is based on Rescue hash function - however, it deviates significantly from the original construction. Security implications of this deviation have not been analyzed. It is possible that this hashing scheme is insecure, and will need to be changed in the future.

The hash function works as follows:

First, a state of 4 field elements is initialized to `0`. Then, the following procedure is applied:
```
for each op_code in the program do:
    add round constants;
    apply s-box;
    apply MDS;
    state[0] = state[0] + state[2] * op_code;
    state[1] = state[1] * state[3] + op_code;
    add round constants;
    apply inverse s-box;
    apply MDS;
```
where `op_code` is the opcode of the operation being executed on the VM. As mentioned above, this is based on the Rescue hash function but with the following significant differences:
1. The opcodes of the program are injected into the state in the middle of every round.
2. The number of rounds is equal to the number of operations in the program.

After the above procedure has been applied for all operations of the program, the first two elements of the state are returned as the hash of the program.

### Turing-completeness
Distaff VM is unlikely to be [Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness) in the foreseeable future. However, even now, you can use `CHOOSE` instructions to simulate conditional branches. In the future, more sophisticated ways to support conditional execution, and maybe even bounded loops, will be added.

### Memory
Currently, Distaff VM has no random access memory - all values live on the stack. However, a memory module will be added in the future to enable saving values to and reading values from RAM.

## Fibonacci calculator
Let's write a simple program for Distaff VM. This program will compute the 5-th [Fibonacci number](https://en.wikipedia.org/wiki/Fibonacci_number):

```
PUSH 0      // stack state: 0
PUSH 1      // stack state: 1 0
SWAP        // stack state: 0 1
DUP2        // stack state: 0 1 0 1
DROP        // stack state: 1 0 1
ADD         // stack state: 1 1
SWAP        // stack state: 1 1
DUP2        // stack state: 1 1 1 1
DROP        // stack state: 1 1 1
ADD         // stack state: 2 1
SWAP        // stack state: 1 2
DUP2        // stack state: 1 2 1 2
DROP        // stack state: 2 1 2
ADD         // stack state: 3 2
```
Notice that except for the first 2 operations which initialize the stack, the sequence of `SWAP DUP2 DROP ADD` operations repeats over and over. In fact, we can repeat these operations an arbitrary number of times to compute an arbitrary Fibonacci number. In Rust, it would like like this (this is actually a simplified version of the example in [fibonacci.rs](https://github.com/GuildOfWeavers/distaff/blob/master/src/examples/fibonacci.rs)):
```Rust
use distaff::{ ProofOptions, ProgramInputs, processor, processor::opcodes::f128 as opcodes };

// set the number of terms to compute
let n = 50;

// build the program
let mut program = vec![opcodes::BEGIN];
for _ in 0..(n - 1) {
    program.push(opcodes::SWAP);
    program.push(opcodes::DUP2);
    program.push(opcodes::DROP);
    program.push(opcodes::ADD);
}

// initialize the stack with values 0 and 1
let inputs = ProgramInputs::from_public(&[1, 0]);

// execute the program
let (outputs, program_hash, proof) = processor::execute(
        &program,
        &inputs,
        1,          // top stack item is the output
        &ProofOptions::default());

// the output should be the 50th Fibonacci number
assert_eq!(vec![12586269025], outputs);
```
Above, we used public inputs to initialize the stack rather than using `PUSH` operations. This makes the program a bit simpler, and also allows us to run the program from arbitrary starting points without changing program hash.

This program is rather efficient: the stack never gets more than 4 items deep.

## Performance
Here are some very informal benchmarks of running the Fibonacci calculator on Intel Core i5-7300U @ 2.60GHz (single thread) for a given number of operations (remember, it takes 3 operations to compute a single Fibonacci term):

| Operation Count | Execution time | Execution RAM  | Verification time | Proof size |
| --------------- | :------------: | :------------: | :---------------: | :--------: |
| 2<sup>8</sup>   | 180 ms         | negligible     | 2 ms              | 58 KB      |
| 2<sup>10</sup>  | 280 ms         | negligible     | 2 ms              | 79 KB      |
| 2<sup>12</sup>  | 1 sec          | < 100 MB       | 2 ms              | 102 KB     |
| 2<sup>14</sup>  | 3.4 sec        | ~ 350 MB       | 3 ms              | 128 KB     |
| 2<sup>16</sup>  | 14 sec         | 1.4 GB         | 3 ms              | 158 KB     |
| 2<sup>18</sup>  | 1 min          | 5.2 GB         | 3 ms              | 188 KB     |
| 2<sup>20</sup>  | 15 min         | > 5.6 GB       | 4 ms              | 225 KB     |

A few notes about the results:
1. Execution time is dominated by the proof generation time. In fact, the time needed to run the program is only about 0.05% of the time needed to generate the proof.
2. For 2<sup>20</sup> case, RAM on my machine maxed out at 5.6 GB, but for efficient execution ~16 GB would be needed. This probably explains why proving time is so poor in this case as compared to other cases. If there was sufficient RAM available, execution time would have likely been around 4 mins.
3. The benchmarks use default proof options which target 120-bit security level. The security level can be increased by either increasing execution time or proof size. In general, there is a trade-off between proof time and proof size (i.e. for a given security level, you can reduce proof size by increasing execution time, up to a point).

## References
Proofs of execution generated by Distaff VM are based on STARKs. A STARK is a novel proof-of-computation scheme that allows you to create an efficiently verifiable proof that a computation was executed correctly. The scheme was developed by Eli-Ben Sasson and team at Technion - Israel Institute of Technology. STARKs do not require an initial trusted setup, and rely on very few cryptographic assumptions.

Here are some resources to learn more about STARKs:

* STARKs whitepaper: [Scalable, transparent, and post-quantum secure computational integrity](https://eprint.iacr.org/2018/046)
* STARKs vs. SNARKs: [A Cambrian Explosion of Crypto Proofs](https://nakamoto.com/cambrian-explosion-of-crypto-proofs/)

Vitalik Buterin's blog series on zk-STARKs:
* [STARKs, part 1: Proofs with Polynomials](https://vitalik.ca/general/2017/11/09/starks_part_1.html)
* [STARKs, part 2: Thank Goodness it's FRI-day](https://vitalik.ca/general/2017/11/22/starks_part_2.html)
* [STARKs, part 3: Into the Weeds](https://vitalik.ca/general/2018/07/21/starks_part_3.html)

StarkWare's STARK Math blog series:
* [STARK Math: The Journey Begins](https://medium.com/starkware/stark-math-the-journey-begins-51bd2b063c71)
* [Arithmetization I](https://medium.com/starkware/arithmetization-i-15c046390862)
* [Arithmetization II](https://medium.com/starkware/arithmetization-ii-403c3b3f4355)
* [Low Degree Testing](https://medium.com/starkware/low-degree-testing-f7614f5172db)
* [A Framework for Efficient STARKs](https://medium.com/starkware/a-framework-for-efficient-starks-19608ba06fbe)

# License
[MIT](/LICENSE) Â© 2020 Guild of Weavers